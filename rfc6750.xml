<?xml version='1.0' encoding='US-ASCII' ?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<rfc category="std" ipr="trust200902" number="6750" submissionType="IETF" consensus="yes">

  <?rfc toc='yes' ?>
  <?rfc tocdepth='3' ?>
  <?rfc symrefs='yes' ?>
  <?rfc sortrefs='yes' ?>
  <?rfc compact='yes' ?>
  <?rfc subcompact='no' ?>
  <?rfc rfcedstyle="yes"?>

  <front>
    <!--title abbrev='OAuth 2.0 Bearer Token Usage'>The OAuth 2.0 Authorization Framework: Bearer&nbsp;Token&nbsp;Usage</title-->
    <title abbrev='OAuth 2.0 Bearer Token Usage'>The OAuth 2.0 Authorization Framework: Bearer&nbsp;Token&nbsp;Usage（日本語）</title>

    <author fullname="Michael B. Jones" surname="Jones" initials="M.B."> <!-- role="editor" -->
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>
    <author fullname='Dick Hardt' surname='Hardt' initials='D'>
      <organization>Independent</organization>
      <address>
        <email>dick.hardt@gmail.com</email>
        <uri>http://dickhardt.org/</uri>
      </address>
    </author>

    <date month="October" year="2012" />

    <area>Security</area>
    <workgroup>OAuth Working Group</workgroup>

    <abstract>
      <!--t>
        This specification describes how to use bearer tokens in HTTP
        requests to access OAuth 2.0 protected resources.
        Any party in possession of a bearer token (a "bearer") can use it to
        get access to the associated resources (without demonstrating
        possession of a cryptographic key).  To prevent misuse, bearer tokens
        need to be protected from disclosure in storage and in transport.
      </t-->
      <t>
        この仕様書は, OAuth 2.0の保護リソースへアクセスするために, 署名無しトークンをHTTPリクエスト中でどのように利用するか記述したものである.
        署名無しトークンを所有する任意のパーティ (持参人) は, 関連づけられたリソースへアクセスするために署名無しトークンを利用できる (暗号鍵の所有を示す必要はない).
        誤った利用を避けるために, 署名無しトークンは保存場所や流通経路での値の露見から守られる必要がある.
      </t>
    </abstract>
  </front>

  <middle>

    <!--section title='Introduction'-->
    <section title='はじめに'>
      <!--t>
        OAuth enables clients to access protected resources by
        obtaining an access token, which is defined in "The OAuth 2.0 Authorization Framework" <xref target="RFC6749"/>
        as "a string representing an access
        authorization issued to the client", rather than using the
        resource owner's credentials directly.
      </t-->
      <t>
        OAuthは, クライアントがアクセストークンを取得することで, 保護リソースへのアクセスを可能にする.
        アクセストークンは "The OAuth 2.0 Authorization Framework" <xref target="RFC6749"/> 中で「クライアントに対するアクセス認可の文字列表現」と定義されており,
        リソース所有者のクレデンシャルを直接利用することではない.
      </t>
      <!--t>
        Tokens are issued to clients by an authorization server with the approval of
        the resource owner. The client uses the access token to access the protected resources
        hosted by the resource server. This specification describes how to make protected resource
        requests when the OAuth access token is a bearer token.
      </t-->
      <t>
        トークンはリソース所有者の承認を伴い, 認可サーバによってクライアントに対して発行される.
        クライアントはアクセストークンを, リソースサーバが持つ保護リソースにアクセスするために利用する.
        この仕様書では, アクセストークンが署名無しトークンである場合に, 保護リソースを要求する方法を記載する.
      </t>
      <!--t>
        This specification defines the use of bearer tokens over
        HTTP/1.1 <xref target='RFC2616'/>
        using Transport Layer Security
        (TLS) <xref target='RFC5246' /> to access protected resources.
        TLS is mandatory to implement
        and use with this specification; other specifications may
        extend this specification for use with other protocols.
        While designed for use with access tokens resulting from OAuth 2.0
        authorization <xref target="RFC6749" /> flows to access OAuth
        protected resources,
        this specification actually defines a general HTTP authorization
        method that can be used with bearer tokens from any source
        to access any resources protected by those bearer tokens.
        The Bearer authentication scheme is intended primarily for
        server authentication using the WWW-Authenticate and
        Authorization HTTP headers but does not preclude its use for
        proxy authentication.
      </t-->
      <t>
       この仕様書では <xref target='RFC2616'>HTTP</xref> 及び <xref target='RFC5246'>TLS</xref> で定義された, TLSを用いたHTTP上でのOAuthで, 署名無しトークンを利用する方法を定める.
        他の仕様書がその他の転送プロトコルの元での利用について本仕様を拡張する可能性もある.
       
       この仕様書では Transport Layer Security
        (TLS) <xref target='RFC5246' /> を利用した HTTP/1.1 <xref target='RFC2616'/> 上で, 保護リソースへアクセスするために署名無しトークンを利用する方法を定める.
       TLSの利用は必須であり, 
      </t>

      <section title='Notational Conventions'>
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
          NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
          described in
          "Key words for use in RFCs to Indicate Requirement Levels" <xref target='RFC2119' />.
        </t>
        <t>
          This document uses the Augmented Backus-Naur Form (ABNF)
          notation of <xref target='RFC5234' />.
          Additionally, the following rules are included from
          HTTP/1.1 <xref target='RFC2617'/>:
          auth-param and auth-scheme; and from
          "Uniform Resource Identifier (URI): Generic Syntax" <xref target='RFC3986' />:
          URI-reference.
        </t>
        <t>
          Unless otherwise noted, all the protocol parameter names and values are case sensitive.
        </t>
      </section>

      <section title='Terminology'>
        <t>
          <list style='hanging'>
            <t hangText="Bearer Token">
              <vspace />
              A security token with the property that any party in
              possession of the token (a "bearer") can use the token
              in any way that any other party in possession of it can.
              Using a bearer token does not require a bearer to prove
              possession of cryptographic key material
              (proof-of-possession).
            </t>
          </list>
        </t>
        <t>
          All other terms are as defined in "The OAuth 2.0
          Authorization Framework" <xref target="RFC6749" />.
        </t>
      </section>

      <section title='Overview'>
        <t>
          OAuth provides a method for clients to access a protected resource on behalf of a
          resource owner. In the general case,
          before a client can access a protected resource, it must first obtain
          an authorization grant from the resource owner and then exchange the authorization grant for
          an access token.
          The access token represents the grant's scope, duration, and
          other attributes granted by the authorization grant. The
          client accesses the protected resource by presenting the
          access token to the resource server.
          In some cases, a client can directly present its own
          credentials to an authorization server to obtain an access
          token without having to first obtain an authorization grant from a
          resource owner.
        </t>

        <t>
          The access token provides an abstraction, replacing different authorization
          constructs (e.g., username and password, assertion) for a single token understood by the
          resource server. This abstraction enables issuing access tokens valid for a short time
          period, as well as removing the resource server's need to understand a wide range of
          authentication schemes.
        </t>

        <figure title='Abstract Protocol Flow' anchor='Figure-1'>
          <artwork><![CDATA[
  +--------+                               +---------------+
  |        |--(A)- Authorization Request ->|   Resource    |
  |        |                               |     Owner     |
  |        |<-(B)-- Authorization Grant ---|               |
  |        |                               +---------------+
  |        |
  |        |                               +---------------+
  |        |--(C)-- Authorization Grant -->| Authorization |
  | Client |                               |     Server    |
  |        |<-(D)----- Access Token -------|               |
  |        |                               +---------------+
  |        |
  |        |                               +---------------+
  |        |--(E)----- Access Token ------>|    Resource   |
  |        |                               |     Server    |
  |        |<-(F)--- Protected Resource ---|               |
  +--------+                               +---------------+
]]></artwork></figure>

        <t>
          The abstract OAuth 2.0 flow illustrated in <xref target='Figure-1' />
          describes the interaction
          between the client, resource owner, authorization server, and
          resource server (described in <xref target="RFC6749"/>).
          The following two steps are specified within this document:
        </t>

          <t>
           <list style='hanging' hangIndent="5">
            <t hangText="(E)">
              The client requests the protected resource from the resource
              server and authenticates
              by presenting the access token.
            </t>
            <t hangText="(F)">
              The resource server validates the access token, and if valid,
              serves the request.
            </t>
          </list>
        </t>

        <t>
          This document also imposes semantic requirements upon the
          access token returned in step (D).
        </t>
      </section>
    </section>

    <section title='Authenticated Requests'>
      <t>
        This section defines three
        methods of sending bearer access tokens in resource requests
        to resource servers.  Clients MUST NOT use more than one
        method to transmit the token in each request.
      </t>

      <section title='Authorization Request Header Field' anchor='authz-header'>
        <t>
          When sending the access token in the <spanx
          style='verb'>Authorization</spanx> request header field
          defined by
          HTTP/1.1 <xref target='RFC2617'/>,
          the
          client uses the <spanx style='verb'>Bearer</spanx>
          authentication scheme to transmit the access token.
        </t>
        <figure>
          <preamble>
            For example:
          </preamble>
          <artwork><![CDATA[
  GET /resource HTTP/1.1
  Host: server.example.com
  Authorization: Bearer mF_9.B5f-4.1JqM
]]></artwork>
        </figure>
        <t>
          The syntax of the <spanx style='verb'>Authorization</spanx> header
          field for this scheme follows the usage of the Basic scheme defined
          in Section 2 of <xref target='RFC2617'/>. Note that, as with Basic,
          it does not conform to the generic syntax defined in Section 1.2
          of <xref target='RFC2617'/> but is compatible with the
          general authentication framework being developed for HTTP&nbsp;1.1
          <xref target="HTTP-AUTH"/>, although it does not
          follow the preferred practice outlined therein in order to
          reflect existing deployments. The syntax for Bearer credentials is
          as follows: 
        </t>

        <figure>
          <artwork><![CDATA[
  b64token    = 1*( ALPHA / DIGIT /
                    "-" / "." / "_" / "~" / "+" / "/" ) *"="
  credentials = "Bearer" 1*SP b64token
]]></artwork>
        </figure>
        <t>
          Clients SHOULD make authenticated requests with a bearer
          token using the <spanx style='verb'>Authorization</spanx>
          request header field with the <spanx
          style='verb'>Bearer</spanx> HTTP authorization scheme.
          Resource servers MUST support this method.
        </t>
      </section>

      <section title='Form-Encoded Body Parameter' anchor='body-param'>
        <t>
          When sending the access token in the HTTP request entity-body,
          the client adds the access token to the request-body
          using the <spanx style='verb'>access_token</spanx>
          parameter.  The client MUST NOT use this method unless
          all of the following conditions are met:
          <list style='symbols'>
            <t>
              The HTTP request entity-header includes the <spanx style='verb'>Content-Type</spanx>
              header field set to <spanx style='verb'>application/x-www-form-urlencoded</spanx>.
            </t>
            <t>
              The entity-body follows the encoding requirements of the
              <spanx style='verb'>application/x-www-form-urlencoded</spanx> content-type as
              defined by
              HTML 4.01 <xref target='W3C.REC-html401-19991224' />.
            </t>
            <t>
              The HTTP request entity-body is single-part.
            </t>
            <t>
              The content to be encoded in the entity-body MUST
              consist entirely of ASCII <xref target="USASCII" /> characters.
            </t>
            <t>
              The HTTP request method is one for which the request-body
              has defined semantics.  In particular,
              this means that the <spanx style='verb'>GET</spanx>
              method MUST NOT be used.
            </t>
          </list>
        </t>
        <t>
          The entity-body MAY include other request-specific
          parameters, in which case the <spanx
          style='verb'>access_token</spanx> parameter MUST be properly
          separated from the request-specific parameters using <spanx
          style='verb'>&amp;</spanx> character(s) (ASCII code 38).
        </t>
        <figure>
          <preamble>
            For example, the client makes the following HTTP request using transport-layer
            security:
          </preamble>
          <artwork><![CDATA[
  POST /resource HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  access_token=mF_9.B5f-4.1JqM
]]></artwork>
        </figure>
        <t>
          The <spanx style='verb'>application/x-www-form-urlencoded</spanx>
          method SHOULD NOT be used except in application contexts
          where participating browsers do not have access to the
          <spanx style='verb'>Authorization</spanx> request header
          field.
          Resource servers MAY support this method.
        </t>
      </section>

      <section title='URI Query Parameter' anchor='query-param'>
        <t>
          When sending the access token in the HTTP request URI, the client adds the access
          token to the request URI query component as defined by
          "Uniform Resource Identifier (URI): Generic Syntax" <xref target='RFC3986' />,
          using
          the <spanx style='verb'>access_token</spanx> parameter.
        </t>
        <figure>
          <preamble>
            For example, the client makes the following HTTP request using transport-layer
            security:
          </preamble>
          <artwork><![CDATA[
  GET /resource?access_token=mF_9.B5f-4.1JqM HTTP/1.1
  Host: server.example.com
]]></artwork>
        </figure>
        <t>
          The HTTP request URI query can include other
          request-specific parameters, in which case the <spanx
          style='verb'>access_token</spanx> parameter MUST be properly
          separated from the request-specific parameters using <spanx
          style='verb'>&amp;</spanx> character(s) (ASCII code 38).
        </t>
        <figure>
          <preamble>
            For example:
          </preamble>
          <artwork><![CDATA[
 https://server.example.com/resource?access_token=mF_9.B5f-4.1JqM&p=q
]]></artwork>
        </figure>
        <t>
          Clients using the URI Query Parameter method SHOULD also send a
          Cache-Control header containing the "no-store" option.  Server success
          (2XX status) responses to these requests SHOULD contain a Cache-Control
          header with the "private" option.
        </t>
        <t>
          Because of the security weaknesses associated with the URI
          method (see <xref target="sec-con" />), including the high
          likelihood that the URL containing the access token will be
          logged, it SHOULD NOT be used unless it is impossible to
          transport the access token in the <spanx
          style='verb'>Authorization</spanx> request header field or
          the HTTP request entity-body.
          Resource servers MAY support this method.
        </t>
        <t>
          This method is included to document current use; its use is
          not recommended, due to its security deficiencies (see
          <xref target="sec-con" />) and also because it uses a
          reserved query parameter name, which is counter to
          URI namespace best practices, per
          "Architecture of the World Wide Web, Volume One" <xref target='W3C.REC-webarch-20041215' />.
        </t>
      </section>

    </section>

    <section title='The WWW-Authenticate Response Header Field' anchor='authn-header'>
      <t>
        If the protected resource request does not include
        authentication credentials or does not contain an access
        token that enables access to the protected resource,
        the resource server MUST include the HTTP <spanx
        style='verb'>WWW-Authenticate</spanx> response header field;
        it MAY include it in response to other conditions as well.
        The <spanx style='verb'>WWW-Authenticate</spanx> header
        field uses the framework defined by
        HTTP/1.1 <xref target='RFC2617'/>.
      </t>
      <t>
        All challenges defined by this specification MUST use the
        auth-scheme value <spanx style='verb'>Bearer</spanx>.  This
        scheme MUST be followed by one or more auth&nbhy;param values.  The
        auth-param attributes used or defined by this specification
        are as follows.  Other auth-param attributes MAY be used as
        well.
      </t>
      <t>
        A <spanx style='verb'>realm</spanx> attribute MAY be included
        to indicate the scope of protection in the manner described in
        HTTP/1.1 <xref target='RFC2617'/>.
        The <spanx style='verb'>realm</spanx> attribute MUST NOT appear more than once.
      </t>
      <t>
        The <spanx style='verb'>scope</spanx> attribute is defined in
        Section 3.3 of <xref target="RFC6749"/>.
        The <spanx style='verb'>scope</spanx> attribute is a space-delimited list
        of case-sensitive scope values
        indicating the required scope of the access token for accessing the requested resource.
        <spanx style='verb'>scope</spanx> values are implementation defined;
        there is no centralized registry for them;
        allowed values are defined by the authorization server.
        The order of <spanx style='verb'>scope</spanx> values is not significant.
        In some cases, the <spanx style='verb'>scope</spanx> value
        will be used when requesting a new access token with
        sufficient scope of access to utilize the protected resource.
        Use of the <spanx style='verb'>scope</spanx> attribute is OPTIONAL.
        The <spanx style='verb'>scope</spanx> attribute MUST NOT appear more than once.
        The <spanx style='verb'>scope</spanx> value is intended for
        programmatic use and is not meant to be displayed to
        end-users. 
      </t>
      <figure>
        <preamble>
          Two example scope values follow; these are taken from the
          OpenID Connect <xref target="OpenID.Messages" /> and the
          Open Authentication Technology Committee (OATC)
          Online Multimedia Authorization Protocol <xref target="OMAP"
          /> OAuth 2.0 use cases, respectively:
        </preamble>
        <artwork><![CDATA[
  scope="openid profile email"
  scope="urn:example:channel=HBO&urn:example:rating=G,PG-13"
]]></artwork>
      </figure>
      <t>
        If the protected resource request included an access token and failed authentication, the
        resource server SHOULD include the <spanx style='verb'>error</spanx> attribute to provide
        the client with the reason why the access request was declined. The parameter value is
        described in <xref target='resource-error-codes' />.
        In addition, the resource server MAY include the <spanx
        style='verb'>error_description</spanx> attribute to provide
        developers a human-readable explanation that is not meant
        to be displayed to end-users.
        It also MAY include
        the <spanx style='verb'>error_uri</spanx> attribute with
        an absolute URI identifying a human-readable web page explaining the error.
        The <spanx style='verb'>error</spanx>, <spanx style='verb'>error_description</spanx>, and
        <spanx style='verb'>error_uri</spanx> attributes MUST NOT appear more than once.
      </t>
      <t>
        Values for the <spanx style='verb'>scope</spanx> attribute
        (specified in Appendix A.4 of <xref target="RFC6749"/>)
        MUST NOT include characters outside the set
        %x21 / %x23-5B / %x5D-7E
        for representing scope values and %x20 for delimiters between scope
        values.
        Values for the <spanx style='verb'>error</spanx> and <spanx
        style='verb'>error_description</spanx> attributes
        (specified in Appendixes A.7 and A.8 of <xref target="RFC6749"/>)
        MUST NOT include
        characters outside the set %x20-21 / %x23-5B / %x5D-7E.
        Values for the <spanx style='verb'>error_uri</spanx> attribute
        (specified in Appendix A.9 of <xref target="RFC6749"/>)
        MUST conform to the URI&nbhy;reference syntax and thus MUST NOT include
        characters outside the set %x21 / %x23-5B / %x5D-7E.
      </t>

      <figure>
        <preamble>
          For example, in response to a protected resource request without authentication:
        </preamble>
        <artwork><![CDATA[
  HTTP/1.1 401 Unauthorized
  WWW-Authenticate: Bearer realm="example"
]]></artwork>
        </figure>
        <figure>
          <preamble>
            And in response to a protected resource request with an authentication attempt using an
            expired access token:
          </preamble>
          <artwork><![CDATA[
  HTTP/1.1 401 Unauthorized
  WWW-Authenticate: Bearer realm="example",
                    error="invalid_token",
                    error_description="The access token expired"
]]></artwork>
      </figure>

      <section title='Error Codes' anchor='resource-error-codes'>
        <t>
          When a request fails, the resource server responds using the appropriate HTTP status
          code (typically, 400, 401, 403, or 405)
          and includes one of the following error codes in
          the response:

          <list style='hanging' hangIndent='6'>
            <t hangText='invalid_request'>
              <vspace />
              The request is missing a required parameter, includes an unsupported parameter or
              parameter value, repeats the same parameter, uses more than one method for
              including an access token, or is otherwise malformed. The resource server SHOULD
              respond with the HTTP 400 (Bad Request) status code.
            </t>
            <t hangText='invalid_token'>
              <vspace />
              The access token provided is expired, revoked, malformed, or invalid for other
              reasons. The resource SHOULD respond with the HTTP 401 (Unauthorized) status
              code. The client MAY request a new access token and retry the protected resource
              request.
            </t>
            <t hangText='insufficient_scope'>
              <vspace />
              The request requires higher privileges than provided by the access token. The
              resource server SHOULD respond with the HTTP 403 (Forbidden) status code and MAY
              include the <spanx style='verb'>scope</spanx> attribute with the scope necessary to
              access the protected resource.
            </t>
          </list>
        </t>
        <t>
          If the request lacks any authentication information (e.g., the client
was unaware that
          authentication is necessary or attempted using an unsupported authentication method),
          the resource server SHOULD NOT include an error code or other error information.
        </t>
        <figure>
          <preamble>
            For example:
          </preamble>
          <artwork><![CDATA[
  HTTP/1.1 401 Unauthorized
  WWW-Authenticate: Bearer realm="example"
]]></artwork>
        </figure>
      </section>

    </section>

    <section title="Example Access Token Response" anchor="ExAccTokResp">
      <t>
        Typically, a bearer token is returned to the client as part of
        an OAuth 2.0 <xref target="RFC6749" /> access token
        response.  An example of such a response is:
      </t>
      <figure><artwork><![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json;charset=UTF-8
  Cache-Control: no-store
  Pragma: no-cache

  {
    "access_token":"mF_9.B5f-4.1JqM",
    "token_type":"Bearer",
    "expires_in":3600,
    "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA"
  }
]]></artwork></figure>

    </section>

    <section title='Security Considerations' anchor="sec-con">

      <t>
        This section describes the relevant security threats regarding
        token handling when using bearer tokens and describes how to
        mitigate these threats.
      </t>

      <section title="Security Threats" anchor="threats">

        <t>
          The following list presents several common threats against
          protocols utilizing some form of tokens. This list of
          threats is based on
          NIST Special Publication 800-63 <xref target="NIST800-63"/>.
          Since this document builds on the
          OAuth 2.0 Authorization specification <xref target="RFC6749" />,
          we exclude a discussion of threats
          that are described there or in related documents.
        </t>

        <t>
          <list style="hanging">
            <t hangText="Token manufacture/modification:">
              An attacker may generate a bogus token or modify the
              token contents (such as the authentication or attribute
              statements) of an existing token, causing the resource
              server to grant inappropriate access to the client.
              For example, an attacker may modify the token to extend
              the validity period; a malicious client may modify the
              assertion to gain access to information that they
              should not be able to view.
            </t>
            <t hangText="Token disclosure:">
              Tokens may contain authentication and attribute
              statements that include sensitive information.
            </t>
            <t hangText="Token redirect:">
              An attacker uses a token generated for consumption by 
              one resource server to gain access to a different
              resource server that mistakenly believes the token to be
              for it.
            </t>
            <t hangText="Token replay:">
              An attacker attempts to use a token that has already
              been used with that resource server in the past.
            </t>
          </list> 
        </t>
      </section> 

      <section title="Threat Mitigation" anchor="mitigation"> 

        <t>
          A large range of threats can be mitigated by protecting the
          contents of the token by using a digital signature or a
          Message Authentication Code (MAC).
          Alternatively, a bearer token can contain a reference to
          authorization information, rather than encoding the
          information directly. Such references MUST be infeasible for
          an attacker to guess; using a reference may require an extra
          interaction between a server and the token issuer to resolve
          the reference to the authorization information.
          The mechanics of such an interaction are not defined by this
          specification.
        </t>
        <t>
          This document does not specify the encoding or the contents
          of the token; hence, detailed recommendations about the means
          of guaranteeing token integrity protection are outside the
          scope of this document.  The token integrity protection MUST
          be sufficient to prevent the token from being modified.
        </t>
        <t>
          To deal with token redirect, it is important for the
          authorization server to include the identity of the intended
          recipients (the audience), typically a single resource
          server (or a list of resource servers), in the token.
          Restricting the use of the token to a specific scope is also
          RECOMMENDED.
        </t>
        <t>
          The authorization server MUST implement TLS.
          Which version(s) ought to be implemented will vary over
          time and will depend on the widespread deployment and known
          security vulnerabilities at the time of implementation.
          At the time of this writing,
          TLS version 1.2 <xref target='RFC5246' />
          is the most recent version, but it has very limited actual
          deployment and might not be readily available in
          implementation toolkits.
          TLS version 1.0 <xref target='RFC2246' />
          is the most widely deployed version and will give the
          broadest interoperability.
        </t>
        <t>
          To protect against token disclosure, confidentiality
          protection MUST be applied using
          TLS <xref target='RFC5246' />
          with a ciphersuite that provides confidentiality and
          integrity protection.  This
          requires that the communication interaction between the
          client and the authorization server, as well as the
          interaction between the client and the resource server,
          utilize confidentiality and integrity protection.
          Since TLS is mandatory to
          implement and to use with this specification, it is the
          preferred approach for preventing token disclosure via the
          communication channel. For those cases where the client
          is prevented from observing the contents of the token, token
          encryption MUST be applied in addition to the usage of TLS
          protection.
          As a further defense against token disclosure, the client
          MUST validate the TLS certificate chain when making requests
          to protected resources, including checking the
          Certificate Revocation List (CRL) <xref target='RFC5280' />.
        </t>
        <t>
          Cookies are typically transmitted in the clear.  Thus, any
          information contained in them is at risk of disclosure.
          Therefore, bearer tokens MUST NOT be stored in cookies that
          can be sent in the clear.
          See "HTTP State Management Mechanism" <xref target='RFC6265' />
          for security considerations about cookies.
        </t>
        <t>
          In some deployments, including those utilizing load
          balancers, the TLS connection to the resource server
          terminates prior to the actual server that provides the
          resource.  This could leave the token unprotected between
          the front-end server where the TLS connection terminates and
          the back-end server that provides the resource.  In such
          deployments, sufficient measures MUST be employed to ensure
          confidentiality of the token between the front-end and
          back-end servers; encryption of the token is one such possible
          measure.
        </t>
        <t>
          To deal with token capture and replay,
          the following recommendations are
          made: First, the lifetime of the token MUST be limited;
          one means of achieving this is by
          putting a validity time field inside the protected part of
          the token.  Note that using short-lived (one hour or less)
          tokens reduces the impact of them being
          leaked.  Second, confidentiality protection of the exchanges
          between the client and the authorization server and between
          the client and the resource server MUST be applied.
          As a
          consequence, no eavesdropper along the communication path is
          able to observe the token exchange. Consequently, such an
          on-path adversary cannot replay the token.
          Furthermore, when
          presenting the token to a resource server, the client MUST
          verify the identity of that resource server, as per
          Section 3.1 of "HTTP Over TLS" <xref target='RFC2818' />.
          Note that the
          client MUST validate the TLS certificate chain when making
          these requests to protected resources.  Presenting the token
          to an unauthenticated and unauthorized resource server or
          failing to validate the certificate chain will allow
          adversaries to steal the token and gain unauthorized access
          to protected resources.
        </t>
      </section> 
 
      <section title="Summary of Recommendations">
        <t>
          <list style="hanging">
            <t hangText="Safeguard bearer tokens:">
              Client implementations MUST ensure that bearer tokens
              are not leaked to unintended parties, as they will be
              able to use them to gain access to protected resources.
              This is the primary security consideration when using
              bearer tokens and underlies all the more
              specific recommendations that follow.
            </t>
            <t hangText="Validate TLS certificate chains:">
              The client MUST validate the TLS certificate chain when
              making requests to protected resources.  Failing to do
              so may enable DNS hijacking attacks to steal the token
              and gain unintended access.
            </t>

            <t hangText="Always use TLS (https):">
              Clients MUST always use
              TLS <xref target='RFC5246' />
              (https) or equivalent transport security when making requests
              with bearer tokens.  Failing to do so exposes the token
              to numerous attacks that could give attackers unintended
              access.
            </t>
            <t hangText="Don't store bearer tokens in cookies:">
              Implementations MUST NOT store bearer tokens within
              cookies that can be sent in the clear (which is the
              default transmission mode for cookies).
              Implementations that do store bearer tokens in cookies
              MUST take precautions against cross-site request forgery.
            </t>
            <t hangText="Issue short-lived bearer tokens:">
              Token servers SHOULD issue short-lived (one hour or
              less) bearer tokens, particularly when issuing tokens to
              clients that run within a web browser or other
              environments where information leakage may occur.  Using
              short-lived bearer tokens can reduce the impact of them
              being leaked.
            </t>
            <t hangText="Issue scoped bearer tokens:">
              Token servers SHOULD issue bearer tokens that contain an audience
              restriction, scoping their use to the intended relying
              party or set of relying parties.
            </t>
            <t hangText="Don't pass bearer tokens in page URLs:">
              Bearer tokens SHOULD NOT be passed in page URLs (for
              example, as query string parameters). Instead, bearer
              tokens SHOULD be passed in HTTP message headers or
              message bodies for which confidentiality measures are
              taken. Browsers, web servers, and other software may not
              adequately secure URLs in the browser history, web
              server logs, and other data structures. If bearer tokens
              are passed in page URLs, attackers might be able to
              steal them from the history data, logs, or other
              unsecured locations.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title='IANA Considerations'>   

      <section title='OAuth Access Token Type Registration'>
        <t>
          This specification registers the following access token type in the
          OAuth Access Token Types registry defined in <xref target="RFC6749"/>.
        </t>

        <section title='The "Bearer" OAuth Access Token Type'>
          <t>
            <list style='hanging'>
              <t hangText='Type name:'>
                <vspace />
                Bearer
              </t>
              <t hangText='Additional Token Endpoint Response Parameters:'>
                <vspace />
                (none)
              </t>
              <t hangText='HTTP Authentication Scheme(s):'>
                <vspace />
                Bearer
              </t>
              <t hangText='Change controller:'>
                <vspace />
                IETF
              </t>
              <t hangText='Specification document(s):'>
                <vspace />
                RFC 6750
              </t>
            </list>
          </t>
        </section>
      </section>

      <section title='OAuth Extensions Error Registration'>
        <t>
          This specification registers the following error values in the
          OAuth Extensions Error registry defined in <xref target="RFC6749"/>.
        </t>

        <section title='The "invalid_request" Error Value'>
          <t>
            <list style='hanging'>
              <t hangText='Error name:'>
                <vspace />
                invalid_request
              </t>
              <t hangText='Error usage location:'>
                <vspace />
                Resource access error response
              </t>
              <t hangText='Related protocol extension:'>
                <vspace />
                Bearer access token type
              </t>
              <t hangText='Change controller:'>
                <vspace />
                IETF
              </t>
              <t hangText='Specification document(s):'>
                <vspace />
                RFC 6750
              </t>
            </list>
          </t>
        </section>

        <section title='The "invalid_token" Error Value'>
          <t>
            <list style='hanging'>
              <t hangText='Error name:'>
                <vspace />
                invalid_token
              </t>
              <t hangText='Error usage location:'>
                <vspace />
                Resource access error response
              </t>
              <t hangText='Related protocol extension:'>
                <vspace />
                Bearer access token type
              </t>
              <t hangText='Change controller:'>
                <vspace />
                IETF
              </t>
              <t hangText='Specification document(s):'>
                <vspace />
                RFC 6750
              </t>
            </list>
          </t>
        </section>

        <section title='The "insufficient_scope" Error Value'>
          <t>
            <list style='hanging'>
              <t hangText='Error name:'>
                <vspace />
                insufficient_scope
              </t>
              <t hangText='Error usage location:'>
                <vspace />
                Resource access error response
              </t>
              <t hangText='Related protocol extension:'>
                <vspace />
                Bearer access token type
              </t>
              <t hangText='Change controller:'>
                <vspace />
                IETF
              </t>
              <t hangText='Specification document(s):'>
                <vspace />
                RFC 6750
              </t>
            </list>
          </t>
        </section>
      </section>

    </section> 

  </middle>

  <back>

  <?rfc rfcedstyle="no"?>
    <references title='Normative References'>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2246.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.6265.xml' ?>

<reference anchor='W3C.REC-html401-19991224'
           target='http://www.w3.org/TR/1999/REC-html401-19991224'>
<front>
<title>HTML 4.01 Specification</title>
<author initials='D.' surname='Raggett' fullname='David Raggett'>
    <organization />
</author>
<author initials='A.' surname='Le Hors' fullname='Arnaud Le Hors'>
    <organization />
</author>
<author initials='I.' surname='Jacobs' fullname='Ian Jacobs'>
    <organization />
</author>
<date month='December' year='1999' />
</front>
<seriesInfo name='World Wide Web Consortium Recommendation'
value='REC-html401-19991224' />
</reference>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-webarch-20041215.xml' ?>

      <reference anchor='RFC6749'>
        <front>
          <title>The OAuth 2.0 Authorization Framework</title>
          <author initials='D' surname='Hardt' fullname='Dick Hardt' role="editor">
            <organization />
          </author>
          <date month="October" year="2012"/>
        </front>
        <seriesInfo name='RFC' value='6749' />
      </reference>

      <reference anchor="USASCII">
        <front>
          <title>Coded Character Set -- 7-bit American Standard Code for Information Interchange</title>
          <author>
            <organization>American National Standards Institute</organization>
          </author>
          <date year="1986"/>
        </front>
        <seriesInfo name="ANSI" value="X3.4"/>
      </reference>

    </references>

    <references title="Informative References">

<!-- draft-ietf-httpbis-p7-auth ("AD is watching") -->
<reference anchor='HTTP-AUTH'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
<author initials='R' surname='Fielding' fullname='Roy Fielding' role="editor">
    <organization />
</author>
<author initials='J' surname='Reschke' fullname='Julian Reschke' role="editor">
    <organization />
</author>
<date month='October' year='2012' />
</front>
<seriesInfo name='Work in' value='Progress' />
</reference>

      <reference anchor="NIST800-63" target="http://csrc.nist.gov/publications/">
        <front>
          <title>NIST Special Publication 800-63-1, INFORMATION SECURITY</title>
          <author fullname="William E. Burr" initials="W." surname="Burr">
            <organization>NIST</organization>
          </author>
          <author fullname="Donna F. Dodson" initials="D." surname="Dodson">
            <organization>NIST</organization>
          </author>
          <author fullname="Elaine M. Newton" initials="E." surname="Newton">
            <organization>NIST</organization>
          </author>
          <author fullname="Ray A. Perlner" initials="R." surname="Perlner">
            <organization>NIST</organization>
          </author>
          <author fullname="W. Timothy Polk" initials="T." surname="Polk">
            <organization>NIST</organization>
          </author>
          <author fullname="Sarbari Gupta" initials="S." surname="Gupta">
            <organization>NIST</organization>
          </author>
          <author fullname="Emad A. Nabbus" initials="E." surname="Nabbus">
            <organization>NIST</organization>
          </author>
          <date month="December" year="2011"/>
        </front>
      </reference>

      <reference anchor="OpenID.Messages" target="http://openid.net/specs/openid-connect-messages-1_0.html">
        <front>
          <title>OpenID Connect Messages 1.0</title>

          <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
            <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
          </author>

          <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization abbrev="Ping Identity">Ping Identity</organization>
          </author>

          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft</organization>
          </author>

          <author fullname="Breno de Medeiros" initials="B." surname="de Medeiros">
            <organization abbrev="Google">Google</organization>
          </author>

          <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
            <organization abbrev="Salesforce">Salesforce</organization>
          </author>

          <author fullname="Edmund Jay" initials="E." surname="Jay">
            <organization abbrev="Illumila">Illumila</organization>
          </author>

          <date day="23" month="June" year="2012" />
        </front>
      </reference>

      <reference anchor="OMAP" target="http://www.oatc.us/Standards/Download.aspx">
        <front>
          <title>Online Multimedia Authorization Protocol:
            An Industry Standard for Authorized Access to Internet Multimedia Resources</title>
          <author fullname="Joel Huff" initials="J." surname="Huff">
            <organization>Adobe Systems</organization>
          </author>
          <author fullname="David Schlacht" initials="D." surname="Schlacht">
            <organization>DirecTV</organization>
          </author>
          <author fullname="Anthony Nadalin" initials="A." surname="Nadalin">
            <organization>Microsoft</organization>
          </author>
          <author fullname="John Simmons" initials="J." surname="Simmons">
            <organization>Microsoft</organization>
          </author>
          <author fullname="Peter Rosenberg" initials="P." surname="Rosenberg">
            <organization>NBC Universal</organization>
          </author>
          <author fullname="Paul Madsen" initials="P." surname="Madsen">
            <organization>Ping Identity</organization>
          </author>
          <author fullname="Tim Ace" initials="T." surname="Ace">
            <organization>Synacor</organization>
          </author>
          <author fullname="Cyril Rickelton-Abdi" initials="C." surname="Rickelton-Abdi">
            <organization>Turner</organization>
          </author>
          <author fullname="Bill Boyer" initials="B." surname="Boyer">
            <organization>Viacom</organization>
          </author>
          <date month="April" year="2012" />
        </front>
      </reference>
    </references> 
  <?rfc rfcedstyle="yes"?>

    <section title='Acknowledgements'>
      <t>
        The following people contributed to preliminary versions of this document:
        Blaine Cook (BT), Brian Eaton (Google), Yaron Y. Goland (Microsoft), Brent Goldman (Facebook),
        Raffi Krikorian (Twitter), Luke Shepard (Facebook), and Allen Tom (Yahoo!). The content and
        concepts within are a product of the OAuth community, the Web Resource
Authorization Profiles (WRAP) community, and the OAuth Working
        Group.
        David Recordon created a preliminary version of this specification
        based upon an early draft of the specification that evolved into
        OAuth&nbsp;2.0 <xref target="RFC6749"/>.
        Michael B. Jones in turn created the first version (00) of this
        specification using portions of
        David's preliminary document and edited all subsequent versions.
      </t>
      <t>
        The OAuth Working Group has dozens of very active contributors who proposed ideas and
        wording for this document, including Michael Adams, Amanda Anganes,
        Andrew Arnott, Derek Atkins, Dirk Balfanz,
        John Bradley, Brian Campbell, Francisco Corella, Leah Culver,
        Bill de hOra, Breno de Medeiros,
        Brian Ellin, Stephen Farrell, Igor Faynberg, George Fletcher,
        Tim Freeman, Evan Gilbert, Yaron Y. Goland, Eran Hammer,
        Thomas Hardjono, Dick Hardt, Justin Hart, Phil Hunt, John Kemp,
        Chasen Le Hara, Barry Leiba, Amos Jeffries, Michael B. Jones,
        Torsten Lodderstedt, Paul Madsen, Eve Maler, James Manger,
        Laurence Miao, William J. Mills, Chuck Mortimore, Anthony Nadalin,
        Axel Nennker, Mark Nottingham, David Recordon, Julian Reschke,
        Rob Richards, Justin Richer, Peter Saint-Andre, Nat Sakimura,
        Rob Sayre, Marius Scurtescu, Naitik Shah, Justin Smith,
        Christian Stuebner, Jeremy Suriel, Doug Tangren, Paul Tarjan,
        Hannes Tschofenig, Franklin Tse, Sean Turner, Paul Walker,
        Shane Weeden, Skylar Woodward, and Zachary Zeltsan.
      </t>
    </section>

  </back>

</rfc>
